{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[412],{811:function(e,a,t){\"use strict\";t.r(a);var r=t(56),s=Object(r.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[t(\"h1\",{attrs:{id:\"building-container-images\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#building-container-images\"}},[e._v(\"#\")]),e._v(\" Building container images\")]),e._v(\" \"),t(\"h2\",{attrs:{id:\"background\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#background\"}},[e._v(\"#\")]),e._v(\" Background\")]),e._v(\" \"),t(\"p\",[e._v(\"In \"),t(\"strong\",[e._v(\"Securing AKS with Snyk\")]),e._v(\", we deployed an application to our Kubernetes cluster running on Microsoft Azure Kubernetes Service (AKS). We deployed this using a \"),t(\"a\",{attrs:{href:\"https://kubernetes.io/docs/concepts/cluster-administration/manage-deployment/\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"manifest\"),t(\"OutboundLink\")],1),e._v(\" template file. The manifest provides a means to organize resource configurations that simplify our deployments. If we examine the \"),t(\"code\",[e._v(\"azure-vote.yaml\")]),e._v(\" we see that we are defining the container images for our back-end and front-end applications as pulling \"),t(\"code\",[e._v(\"redis\")]),e._v(\" and \"),t(\"code\",[e._v(\"microsoft/azure-vote-front:v1\")]),e._v(\" respectively.\")]),e._v(\" \"),t(\"p\",[e._v(\"Later, when we scanned our Kubernetes workload, we found vulnerabilities in our Kubernetes security configuration as well as our container images. We were able to fix the security configuration issues detected. However, when we examined our container images, we noticed the following alert:\")]),e._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://partner-workshop-assets.s3.us-east-2.amazonaws.com/snyk_scan_06.png\",alt:\"\"}})]),e._v(\" \"),t(\"p\",[e._v(\"In this module, we will cover some best practices for building container images, storing these in a private registry like ACR, and monitoring those registries with Snyk.\")]),e._v(\" \"),t(\"h2\",{attrs:{id:\"building-a-docker-image\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#building-a-docker-image\"}},[e._v(\"#\")]),e._v(\" Building a Docker image\")]),e._v(\" \"),t(\"p\",[e._v(\"In Snyk’s \"),t(\"a\",{attrs:{href:\"https://snyk.io/blog/top-ten-most-popular-docker-images-each-contain-at-least-30-vulnerabilities/\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"State of open source security report – 2019\"),t(\"OutboundLink\")],1),e._v(\", we found that many of the popular Docker containers that are featured on the Docker Hub website are bundling images that contain many known vulnerabilities. We encourage you to read this report and as well as our recent blog, \"),t(\"a\",{attrs:{href:\"https://snyk.io/blog/10-docker-image-security-best-practices/\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"10 Docker Image Security Best Practices\"),t(\"OutboundLink\")],1),e._v(\" for a deeper dive on the subject. The following exercises are aligned with these best practices and we will cover them in stages starting with the concept of \"),t(\"code\",[e._v(\"minimal images\")]),e._v(\".\")]),e._v(\" \"),t(\"h3\",{attrs:{id:\"dockerfile\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#dockerfile\"}},[e._v(\"#\")]),e._v(\" Dockerfile\")]),e._v(\" \"),t(\"p\",[e._v(\"Let's start with our back-end application. We see from our manifest that we are using the \"),t(\"a\",{attrs:{href:\"https://docs.docker.com/docker-hub/official_repos/\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"Docker Official Image\"),t(\"OutboundLink\")],1),e._v(\" for \"),t(\"a\",{attrs:{href:\"https://hub.docker.com/_/redis\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"redis\"),t(\"OutboundLink\")],1),e._v(\". We will take the first step in improving our security posture by building a fresh image from a \"),t(\"code\",[e._v(\"Dockerfile\")]),e._v(\" and storing this in our private registry on ACR.\")]),e._v(\" \"),t(\"p\",[e._v(\"From the terminal, let's make sure we are at the root of our cloned repository by typing \"),t(\"code\",[e._v(\"pwd\")]),e._v(\" and verifying the result displays \"),t(\"code\",[e._v(\"$HOME/snyk-azure-resources/\")]),e._v(\". Our repo contains a \"),t(\"a\",{attrs:{href:\"https://git-scm.com/book/en/v2/Git-Tools-Submodules\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t(\"code\",[e._v(\"submodule\")]),t(\"OutboundLink\")],1),e._v(\" that points to the source for the official redis image which happens to include a Dockerfile. To synchronize the submodule, type the following command:\")]),e._v(\" \"),t(\"div\",{staticClass:\"language-bash extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-bash\"}},[t(\"code\",[t(\"span\",{pre:!0,attrs:{class:\"token function\"}},[e._v(\"git\")]),e._v(\" submodule update --recursive\\n\")])])]),t(\"p\",[e._v(\"Then, let's change directory by typing the following command:\")]),e._v(\" \"),t(\"div\",{staticClass:\"language-bash extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-bash\"}},[t(\"code\",[t(\"span\",{pre:!0,attrs:{class:\"token builtin class-name\"}},[e._v(\"cd\")]),e._v(\" app/redis/6.0/\\n\")])])]),t(\"p\",[e._v(\"From here, a simple \"),t(\"code\",[e._v(\"ls -a\")]),e._v(\" command will show the contents and you will see a \"),t(\"code\",[e._v(\"Dockerfile\")]),e._v(\" in that directory. You can open this in your favorite editor like \"),t(\"a\",{attrs:{href:\"https://code.visualstudio.com/\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"Microsoft Visual Studio Code\"),t(\"OutboundLink\")],1),e._v(\" and review the contents. The top few lines should look similar to this:\")]),e._v(\" \"),t(\"div\",{staticClass:\"language-text extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"FROM debian:buster-slim\\n\\n# add our user and group first to make sure their IDs get assigned consistently, regardless of whatever dependencies get added\\nRUN groupadd -r -g 999 redis &amp;&amp; useradd -r -g redis -u 999 redis\\n\")])])]),t(\"p\",[e._v(\"We will come back to this \"),t(\"code\",[e._v(\"Dockerfile\")]),e._v(\" later, but for now, take note that the underlying base image is \"),t(\"code\",[e._v(\"debian:buster-slim\")]),e._v(\".\")]),e._v(\" \"),t(\"h3\",{attrs:{id:\"docker-build\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#docker-build\"}},[e._v(\"#\")]),e._v(\" Docker build\")]),e._v(\" \"),t(\"p\",[e._v(\"Now, from the \"),t(\"code\",[e._v(\"app/redis/6.0/\")]),e._v(\" directory, we will build and tag our own container image using the provided \"),t(\"code\",[e._v(\"Dockerfile\")]),e._v(\". To do so, we will run the \"),t(\"a\",{attrs:{href:\"https://docs.docker.com/engine/reference/commandline/build/\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t(\"code\",[e._v(\"docker build\")]),t(\"OutboundLink\")],1),e._v(\" command as follows:\")]),e._v(\" \"),t(\"div\",{staticClass:\"language-bash extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-bash\"}},[t(\"code\",[t(\"span\",{pre:!0,attrs:{class:\"token function\"}},[e._v(\"docker\")]),e._v(\" build -t my-redis:v1 \"),t(\"span\",{pre:!0,attrs:{class:\"token builtin class-name\"}},[e._v(\".\")]),e._v(\"\\n\")])])]),t(\"p\",[e._v(\"Upon successful completion we should see results similar to the following:\")]),e._v(\" \"),t(\"div\",{staticClass:\"language-text extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"Successfully built aa8130687a13\\nSuccessfully tagged my-redis:v1\\n\")])])]),t(\"h3\",{attrs:{id:\"docker-tag\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#docker-tag\"}},[e._v(\"#\")]),e._v(\" Docker tag\")]),e._v(\" \"),t(\"p\",[e._v(\"We are almost ready to push our initial image to an Azure Container registry. However, before we proceed, we will need to run a few \"),t(\"a\",{attrs:{href:\"https://docs.docker.com/engine/reference/commandline/tag/\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t(\"code\",[e._v(\"docker tag\")]),t(\"OutboundLink\")],1),e._v(\" commands to tag our image with the fully qualified name of your ACR login server. We are going to make this interesting by querying the value of our ACR login server using the Azure CLI within our \"),t(\"code\",[e._v(\"docker tag\")]),e._v(\" command. To do this, we will invoke \"),t(\"code\",[e._v(\"az acr show\")]),e._v(\" and specify our registry name while formatting our output with the \"),t(\"code\",[e._v(\"-o tsv\")]),e._v(\" parameter for plain text.\")]),e._v(\" \"),t(\"div\",{staticClass:\"language-bash extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-bash\"}},[t(\"code\",[t(\"span\",{pre:!0,attrs:{class:\"token function\"}},[e._v(\"docker\")]),e._v(\" tag my-redis:v1 \"),t(\"span\",{pre:!0,attrs:{class:\"token variable\"}},[t(\"span\",{pre:!0,attrs:{class:\"token variable\"}},[e._v(\"$(\")]),e._v(\"az acr show --name mySnykContainerRegistry --query loginServer --output tsv\"),t(\"span\",{pre:!0,attrs:{class:\"token variable\"}},[e._v(\")\")])]),e._v(\"/my-redis:v1\\n\")])])]),t(\"p\",[e._v(\"We tagged the first with a \"),t(\"code\",[e._v(\"version\")]),e._v(\" and we will tag it a second time with \"),t(\"code\",[e._v(\"latest\")]),e._v(\".\")]),e._v(\" \"),t(\"div\",{staticClass:\"language-bash extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-bash\"}},[t(\"code\",[t(\"span\",{pre:!0,attrs:{class:\"token function\"}},[e._v(\"docker\")]),e._v(\" tag my-redis:v1 \"),t(\"span\",{pre:!0,attrs:{class:\"token variable\"}},[t(\"span\",{pre:!0,attrs:{class:\"token variable\"}},[e._v(\"$(\")]),e._v(\"az acr show --name mySnykContainerRegistry --query loginServer --output tsv\"),t(\"span\",{pre:!0,attrs:{class:\"token variable\"}},[e._v(\")\")])]),e._v(\"/my-redis:latest\\n\")])])]),t(\"p\",[e._v(\"Now, we will run a quick \"),t(\"a\",{attrs:{href:\"https://docs.docker.com/engine/reference/commandline/images/\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t(\"code\",[e._v(\"docker images\")]),t(\"OutboundLink\")],1),e._v(\" and make sure everything is correctly tagged.\")]),e._v(\" \"),t(\"div\",{staticClass:\"language-text extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"REPOSITORY                                                      TAG                 IMAGE ID            CREATED             SIZE\\nmy-redis                                                        v1                  aa8130687a13        4 hours ago         104MB\\nmysnykcontainerregistry.azurecr.io/my-redis                     latest              aa8130687a13        4 hours ago         104MB\\nmysnykcontainerregistry.azurecr.io/my-redis                     v1                  aa8130687a13        4 hours ago         104MB\\ndebian                                                          buster-slim         e5aad4204d00        7 days ago          69.2MB\\n\")])])]),t(\"h3\",{attrs:{id:\"docker-push\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#docker-push\"}},[e._v(\"#\")]),e._v(\" Docker push\")]),e._v(\" \"),t(\"p\",[e._v(\"We made it. We are now ready to run \"),t(\"a\",{attrs:{href:\"https://docs.docker.com/engine/reference/commandline/push/\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t(\"code\",[e._v(\"docker push\")]),t(\"OutboundLink\")],1),e._v(\" on our tagged images and store these in ACR. Let's start with the first tagged image \"),t(\"code\",[e._v(\"v1\")]),e._v(\":\")]),e._v(\" \"),t(\"div\",{staticClass:\"language-bash extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-bash\"}},[t(\"code\",[e._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token function\"}},[e._v(\"docker\")]),e._v(\" push \"),t(\"span\",{pre:!0,attrs:{class:\"token variable\"}},[t(\"span\",{pre:!0,attrs:{class:\"token variable\"}},[e._v(\"$(\")]),e._v(\"az acr show --name mySnykContainerRegistry --query loginServer --output tsv\"),t(\"span\",{pre:!0,attrs:{class:\"token variable\"}},[e._v(\")\")])]),e._v(\"/my-redis:v1\\n\")])])]),t(\"p\",[e._v(\"You should see output similar to what's below:\")]),e._v(\" \"),t(\"div\",{staticClass:\"language-text extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"The push refers to repository [mysnykcontainerregistry.azurecr.io/my-redis]\\n555634e64cd8: Pushed\\n12534748095c: Pushed\\nea013d725bd6: Pushed\\n63689ea7c92e: Pushed\\n2c2aedafe0c2: Pushed\\nc2adabaecedb: Pushed\\nv1: digest: sha256:f8e1a610528d3fbd6f1b26fc2a2610c05fd07938b68e8aef7cb87ef1c9a6ec65 size: 1573\\n\")])])]),t(\"p\",[e._v(\"Next, our second tagged image, \"),t(\"code\",[e._v(\"latest\")]),e._v(\":\")]),e._v(\" \"),t(\"div\",{staticClass:\"language-bash extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-bash\"}},[t(\"code\",[t(\"span\",{pre:!0,attrs:{class:\"token function\"}},[e._v(\"docker\")]),e._v(\" push \"),t(\"span\",{pre:!0,attrs:{class:\"token variable\"}},[t(\"span\",{pre:!0,attrs:{class:\"token variable\"}},[e._v(\"$(\")]),e._v(\"az acr show --name mySnykContainerRegistry --query loginServer --output tsv\"),t(\"span\",{pre:!0,attrs:{class:\"token variable\"}},[e._v(\")\")])]),e._v(\"/my-redis:latest\\n\")])])]),t(\"p\",[e._v(\"You should see output similar to what's below:\")]),e._v(\" \"),t(\"div\",{staticClass:\"language-text extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"555634e64cd8: Layer already exists\\n12534748095c: Layer already exists\\nea013d725bd6: Layer already exists\\n63689ea7c92e: Layer already exists\\n2c2aedafe0c2: Layer already exists\\nc2adabaecedb: Layer already exists\\nlatest: digest: sha256:f8e1a610528d3fbd6f1b26fc2a2610c05fd07938b68e8aef7cb87ef1c9a6ec65 size: 1573\\n\")])])]),t(\"p\",[e._v(\"We can also verify these were indeed pushed to our registry by querying through the Azure CLI.\")]),e._v(\" \"),t(\"div\",{staticClass:\"language-bash extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-bash\"}},[t(\"code\",[e._v(\"az acr repository list --name mySnykContainerRegistry --output json\\n\")])])]),t(\"p\",[e._v(\"You should see output similar to what's below:\")]),e._v(\" \"),t(\"div\",{staticClass:\"language-text extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v('[\\n  \"my-redis\"\\n]\\n')])])]),t(\"p\",[e._v(\"To verify the list of tags in our \"),t(\"code\",[e._v(\"my-redis\")]),e._v(\" repository matches what we pushed, we can run the following command:\")]),e._v(\" \"),t(\"div\",{staticClass:\"language-bash extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-bash\"}},[t(\"code\",[e._v(\"az acr repository show-tags --name mySnykContainerRegistry --repository my-redis --output table\\n\")])])]),t(\"p\",[e._v(\"We should see output similar to what's below:\")]),e._v(\" \"),t(\"div\",{staticClass:\"language-text extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[e._v(\"Result\\n--------\\nlatest\\nv1\\n\")])])]),t(\"p\",[e._v(\"Of course, we can also view the same results from the Azure portal:\")]),e._v(\" \"),t(\"p\",[t(\"img\",{attrs:{src:\"https://partner-workshop-assets.s3.us-east-2.amazonaws.com/acr_repository_01.png\",alt:\"\"}})])])}),[],!1,null,null,null);a.default=s.exports}}]);","extractedComments":[]}