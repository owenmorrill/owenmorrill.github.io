{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[864],{1268:function(e,t,a){\"use strict\";a.r(t);var s=a(56),n=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[a(\"h1\",{attrs:{id:\"section-6-secure-your-container-image\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#section-6-secure-your-container-image\"}},[e._v(\"#\")]),e._v(\" Section 6: Secure your Container Image\")]),e._v(\" \"),a(\"p\",[e._v(\"In the previous section, we saw how Snyk presents other Base Images we can use with our container to remedy multiple vulnerabilities at once. In this section, we'll select a more secure base image for our container. Let's get started!\")]),e._v(\" \"),a(\"h2\",{attrs:{id:\"step-1-modify-the-dockerfile-in-github\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#step-1-modify-the-dockerfile-in-github\"}},[e._v(\"#\")]),e._v(\" Step 1: Modify the Dockerfile in GitHub\")]),e._v(\" \"),a(\"p\",[e._v(\"In GitHub, navigate to your Repo and click on the Dockerfile to open it.\")]),e._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://partner-workshop-assets.s3.us-east-2.amazonaws.com/gh-container-opendockerfile.png\",alt:\"\"}})]),e._v(\" \"),a(\"p\",[e._v(\"Click the Edit icon to open the GitHub Web Editor.\")]),e._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://partner-workshop-assets.s3.us-east-2.amazonaws.com/gh-container-dockerfileedit.png\",alt:\"\"}})]),e._v(\" \"),a(\"p\",[e._v(\"Comment out (or delete) the old \"),a(\"code\",[e._v(\"FROM\")]),e._v(\" statement in the Dockerfile, and add a new one from the list of Snyk's recommendations. In this example, we'll use \"),a(\"code\",[e._v(\"node:14-stretch\")]),e._v(\". Your Dockerfile should now look like this:\")]),e._v(\" \"),a(\"div\",{staticClass:\"language-text extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v('#FROM node:6-stretch\\nFROM node:14-stretch\\n\\nRUN mkdir /usr/src/goof\\nRUN mkdir /tmp/extracted_files\\nCOPY . /usr/src/goof\\nWORKDIR /usr/src/goof\\n\\nRUN npm update\\nRUN npm install\\nEXPOSE 3001\\nEXPOSE 9229\\nENTRYPOINT [\"npm\", \"start\"]\\n')])])]),a(\"p\",[e._v(\"{% hint style=\\\"danger\\\" %}\\nThis is an educational example. Upgrading from Node 6 to Node 14 won't always work for your application. Outside of this Lab, you need to understand your application and its dependencies when selecting a base image, as it isn't guaranteed to work when jumping versions like this.\\n{% endhint %}\")]),e._v(\" \"),a(\"p\",[e._v(\"When ready to Commit the changes, select the option to create a \"),a(\"strong\",[e._v(\"new branch\")]),e._v(\" for this commit and propose the changes to the \"),a(\"code\",[e._v(\"Dockerfile\")]),e._v(\".\")]),e._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://partner-workshop-assets.s3.us-east-2.amazonaws.com/gh-container-baseimagebranch.png\",alt:\"\"}})]),e._v(\" \"),a(\"p\",[e._v(\"In the next view, go ahead and create the Pull Request.\")]),e._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://partner-workshop-assets.s3.us-east-2.amazonaws.com/gh-container-baseimagepr.png\",alt:\"\"}})]),e._v(\" \"),a(\"h2\",{attrs:{id:\"step-2-verify-that-the-ci-job-completes-successfully\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#step-2-verify-that-the-ci-job-completes-successfully\"}},[e._v(\"#\")]),e._v(\" Step 2: Verify that the CI job completes successfully\")]),e._v(\" \"),a(\"p\",[e._v(\"In the Pull Request view, make sure your application and container build successfully on top of the new base image by ensuring the \"),a(\"code\",[e._v(\"build-container\")]),e._v(\" check completes successfully.\")]),e._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://partner-workshop-assets.s3.us-east-2.amazonaws.com/gh-container-baseimageprchecks.png\",alt:\"\"}})]),e._v(\" \"),a(\"p\",[e._v(\"When ready, merge the Pull Request to bring our changes into \"),a(\"code\",[e._v(\"develop\")]),e._v(\" and delete the \"),a(\"code\",[e._v(\"replace-base-image\")]),e._v(\" branch when done.\")]),e._v(\" \"),a(\"h2\",{attrs:{id:\"step-3-review-the-new-vulnerability-scan-results\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#step-3-review-the-new-vulnerability-scan-results\"}},[e._v(\"#\")]),e._v(\" Step 3: Review the new Vulnerability Scan results\")]),e._v(\" \"),a(\"p\",[e._v(\"With our new Base Image in place, we can review the vulnerability scan results from Snyk Container once again to see what vulnerabilities we have left to triage in our container image.\")]),e._v(\" \"),a(\"h3\",{attrs:{id:\"github-security-code-scanning\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#github-security-code-scanning\"}},[e._v(\"#\")]),e._v(\" GitHub Security Code Scanning\")]),e._v(\" \"),a(\"p\",[e._v(\"You can review vulnerability counts in GitHub Security Code Scanning, as shown in the previous section.\")]),e._v(\" \"),a(\"p\",[e._v('{% hint style=\"warning\" %}\\nResults in Security Code Scanning take time to update. You won\\'t see updated vulnerability counts until the CI Workflow completes after code has been merged into '),a(\"code\",[e._v(\"develop\")]),e._v(\".\\n{% endhint %}\")]),e._v(\" \"),a(\"h3\",{attrs:{id:\"snyk-ui\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#snyk-ui\"}},[e._v(\"#\")]),e._v(\" Snyk UI\")]),e._v(\" \"),a(\"p\",[e._v(\"In the Snyk UI, the results for the Dockerfile update automatically once the changes are merged into the default working branch. We can see that simply by changing the base image we used, we went from 836 issues to 307! Now we only have 35 high severity vulnerabilities to triage, as opposed to the 203 from before.\")]),e._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://partner-workshop-assets.s3.us-east-2.amazonaws.com/snyk-container-newbasevulns%20%281%29.png\",alt:\"\"}})]),e._v(\" \"),a(\"h2\",{attrs:{id:\"step-4-merge-the-changes-to-prod\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#step-4-merge-the-changes-to-prod\"}},[e._v(\"#\")]),e._v(\" Step 4: Merge the changes to PROD\")]),e._v(\" \"),a(\"p\",[e._v(\"We have outstanding vulnerabilities to take care of, but we need to push our changes to PROD in order to sustain the pace of delivery. We feel good about what we push to PROD, since it's a best effort progressing delivery while keeping the workload secure.\")]),e._v(\" \"),a(\"p\",[e._v(\"Let's open a PR from \"),a(\"code\",[e._v(\"develop\")]),e._v(\" to \"),a(\"code\",[e._v(\"PROD\")]),e._v(\" to check in our work for the day.\")]),e._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://partner-workshop-assets.s3.us-east-2.amazonaws.com/gh-container-prprod.png\",alt:\"\"}})]),e._v(\" \"),a(\"p\",[e._v(\"Once all checks pass, go ahead and merge the PR. Hooray! Our container is now PROD-ready!\")]),e._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://partner-workshop-assets.s3.us-east-2.amazonaws.com/gh-container-prodchecks.png\",alt:\"\"}})]),e._v(\" \"),a(\"h4\",{attrs:{id:\"wait-a-minute-what-about-our-snyk-gate\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#wait-a-minute-what-about-our-snyk-gate\"}},[e._v(\"#\")]),e._v(\" Wait a minute, what about our Snyk Gate?\")]),e._v(\" \"),a(\"p\",[e._v(\"In Part 1, we added a Snyk gate that prevents high-severity vulnerabilities from entering our PROD branch, so why can we merge to PROD even though high severity vulnerabilities are present?\")]),e._v(\" \"),a(\"p\",[e._v(\"In short, we opted to not add container vulnerabilities to the Snyk gate. It still evaluates application vulnerabilities, but in order to not overburden our developers, we opted to not implement it for our container base image.\")]),e._v(\" \"),a(\"h2\",{attrs:{id:\"recap-next-steps\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#recap-next-steps\"}},[e._v(\"#\")]),e._v(\" Recap & Next Steps\")]),e._v(\" \"),a(\"p\",[e._v(\"In this Lab we containerized our sample application and ensured we're using the most secure base image available that's compatible with our application. We ensured, with our CI workflows, that the base image recommended by Snyk is compatible with our application.\")]),e._v(\" \"),a(\"p\",[e._v(\"We also saw how results from Snyk Container can be consumed directly in the GitHub UI using their Security Code Scanning functionality. This allows developers to access Snyk vulnerability information without leaving GitHub's UI.\")]),e._v(\" \"),a(\"p\",[e._v(\"In the next section, we take our application, and our security testing, a step further by introducing the files that will allow us to deploy this container to an orchestrated environment. When ready to start playing with Snyk Infrastructure as Code, proceed to Part 3!\")])])}),[],!1,null,null,null);t.default=n.exports}}]);","extractedComments":[]}